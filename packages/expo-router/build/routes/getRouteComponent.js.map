{"version":3,"file":"getRouteComponent.js","sourceRoot":"","sources":["../../src/routes/getRouteComponent.tsx"],"names":[],"mappings":"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","sourcesContent":["'use client';\n\nimport { useIsFocused, useStateForPath } from '@react-navigation/native';\nimport React from 'react';\n\nimport { LoadedRoute, Route, RouteNode } from '../Route';\nimport { useExpoRouterStore } from '../global-state/storeContext';\nimport EXPO_ROUTER_IMPORT_MODE from '../import-mode';\nimport { EmptyRoute } from '../views/EmptyRoute';\nimport { SuspenseFallback } from '../views/SuspenseFallback';\nimport { Try } from '../views/Try';\n\n// TODO: Maybe there's a more React-y way to do this?\n// Without this store, the process enters a recursive loop.\nconst qualifiedStore = new WeakMap<RouteNode, React.ComponentType<any>>();\n\n/** Wrap the component with various enhancements and add access to child routes. */\nexport function getQualifiedRouteComponent(value: RouteNode) {\n  if (qualifiedStore.has(value)) {\n    return qualifiedStore.get(value)!;\n  }\n\n  let ScreenComponent:\n    | React.ForwardRefExoticComponent<React.RefAttributes<unknown>>\n    | React.ComponentType<any>;\n\n  // TODO: This ensures sync doesn't use React.lazy, but it's not ideal.\n  if (EXPO_ROUTER_IMPORT_MODE === 'lazy') {\n    ScreenComponent = React.lazy(async () => {\n      const res = value.loadRoute();\n      return fromLoadedRoute(value, res) as Promise<{\n        default: React.ComponentType<any>;\n      }>;\n    });\n\n    if (__DEV__) {\n      ScreenComponent.displayName = `AsyncRoute(${value.route})`;\n    }\n  } else {\n    const res = value.loadRoute();\n    ScreenComponent = fromImport(value, res).default!;\n  }\n  function BaseRoute({\n    // Remove these React Navigation props to\n    // enforce usage of expo-router hooks (where the query params are correct).\n    route,\n    navigation,\n\n    // Pass all other props to the component\n    ...props\n  }: any) {\n    const stateForPath = useStateForPath();\n    const isFocused = useIsFocused();\n    const store = useExpoRouterStore();\n\n    if (isFocused) {\n      const state = navigation.getState();\n      const isLeaf = !('state' in state.routes[state.index]);\n      if (isLeaf && stateForPath) store.setFocusedState(stateForPath);\n    }\n\n    return (\n      <Route node={value} route={route}>\n        <React.Suspense fallback={<SuspenseFallback route={value} />}>\n          <ScreenComponent\n            {...props}\n            // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`\n            // the intention is to make it possible to deduce shared routes.\n            segment={value.route}\n          />\n        </React.Suspense>\n      </Route>\n    );\n  }\n\n  if (__DEV__) {\n    BaseRoute.displayName = `Route(${value.route})`;\n  }\n\n  qualifiedStore.set(value, BaseRoute);\n  return BaseRoute;\n}\n\nfunction fromLoadedRoute(value: RouteNode, res: LoadedRoute) {\n  if (!(res instanceof Promise)) {\n    return fromImport(value, res);\n  }\n\n  return res.then(fromImport.bind(null, value));\n}\n\nfunction fromImport(value: RouteNode, { ErrorBoundary, ...component }: LoadedRoute) {\n  // If possible, add a more helpful display name for the component stack to improve debugging of React errors such as `Text strings must be rendered within a <Text> component.`.\n  if (component?.default && __DEV__) {\n    component.default.displayName ??= `${component.default.name ?? 'Route'}(${value.contextKey})`;\n  }\n\n  if (ErrorBoundary) {\n    const Wrapped = React.forwardRef((props: any, ref: any) => {\n      const children = React.createElement(component.default || EmptyRoute, {\n        ...props,\n        ref,\n      });\n      return <Try catch={ErrorBoundary}>{children}</Try>;\n    });\n\n    if (__DEV__) {\n      Wrapped.displayName = `ErrorBoundary(${value.contextKey})`;\n    }\n\n    return {\n      default: Wrapped,\n    };\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      typeof component.default === 'object' &&\n      component.default &&\n      Object.keys(component.default).length === 0\n    ) {\n      return { default: EmptyRoute };\n    }\n  }\n\n  return { default: component.default };\n}\n"]}